{
  "name": "implement-feature",
  "description": "Implement feature to pass specified tests using TDD workflow",
  "agent": "agents/integration_agent.md",
  "context": "contexts/integration_context.md",
  "parameters": {
    "test-path": {
      "type": "string",
      "description": "Path to test file or test module",
      "required": true
    },
    "feature-type": {
      "type": "string",
      "description": "Type of feature (crypto, network, dag, protocol, integration)",
      "required": false
    },
    "integration-points": {
      "type": "array",
      "description": "Components that need integration with this feature",
      "required": false,
      "items": ["crypto", "dag", "network", "protocol"]
    },
    "tdd-phase": {
      "type": "string",
      "description": "TDD phase to execute (red, green, refactor, all)",
      "required": false,
      "default": "all"
    }
  },
  "examples": [
    "/implement-feature tests/crypto/ml_kem_test.rs",
    "/implement-feature tests/network/peer_test.rs --feature-type network",
    "/implement-feature tests/integration/crypto_dag_test.rs --integration-points crypto,dag",
    "/implement-feature tests/protocol/handshake_test.rs --tdd-phase green",
    "/implement-feature tests/integration/end_to_end_test.rs --feature-type integration --integration-points crypto,dag,network,protocol"
  ],
  "workflow": {
    "tdd_phases": {
      "red": {
        "description": "Ensure tests fail appropriately",
        "steps": [
          "1. Analyze test requirements",
          "2. Identify missing implementations",
          "3. Verify test failure patterns",
          "4. Document expected behavior"
        ]
      },
      "green": {
        "description": "Implement minimal code to pass tests",
        "steps": [
          "1. Implement core functionality",
          "2. Handle edge cases from tests",
          "3. Ensure all tests pass",
          "4. Verify no regression in existing tests"
        ]
      },
      "refactor": {
        "description": "Optimize and clean up implementation",
        "steps": [
          "1. Improve code structure",
          "2. Optimize performance",
          "3. Enhance documentation",
          "4. Ensure tests still pass"
        ]
      }
    },
    "integration_workflow": [
      "1. Analyze integration requirements from tests",
      "2. Identify component dependencies",
      "3. Implement component interfaces",
      "4. Add integration glue code",
      "5. Validate end-to-end functionality",
      "6. Update integration documentation"
    ]
  },
  "templates": {
    "feature_implementation": {
      "structure": [
        "// Feature module structure",
        "mod feature_name {",
        "    use super::*;",
        "    ",
        "    // Core implementation",
        "    pub struct FeatureImpl { ... }",
        "    ",
        "    // Integration traits",
        "    impl ComponentTrait for FeatureImpl { ... }",
        "    ",
        "    // Error handling",
        "    #[derive(Error, Debug)]",
        "    pub enum FeatureError { ... }",
        "}"
      ]
    },
    "integration_implementation": {
      "pattern": [
        "// Integration layer",
        "pub struct IntegratedFeature {",
        "    crypto: Arc<CryptoComponent>,",
        "    network: Arc<NetworkComponent>,",
        "    dag: Arc<DagComponent>,",
        "}",
        "",
        "impl IntegratedFeature {",
        "    pub async fn execute(&self) -> Result<()> {",
        "        // Coordinate components",
        "    }",
        "}"
      ]
    }
  },
  "coordination": {
    "agents": [
      "integration_agent: Feature implementation coordination",
      "crypto_agent: Cryptographic feature implementation",
      "network_agent: Network feature implementation",
      "consensus_agent: DAG/consensus feature implementation",
      "security_agent: Security review of implementation",
      "performance_agent: Performance validation"
    ],
    "cross_component": [
      "1. Identify cross-component dependencies",
      "2. Coordinate implementation across agents",
      "3. Ensure consistent interfaces",
      "4. Validate integration points",
      "5. Update component documentation"
    ]
  },
  "output": {
    "success": "Feature implementation with comprehensive validation",
    "format": [
      "1. Implementation Summary",
      "   - Feature description",
      "   - Components modified",
      "   - Integration points added",
      "2. Test Results",
      "   - Unit tests: X/Y passing",
      "   - Integration tests: X/Y passing",
      "   - Performance tests: metrics",
      "3. Code Analysis",
      "   - Lines added/modified",
      "   - Code coverage: before/after",
      "   - Complexity metrics",
      "4. Integration Validation",
      "   - Component interactions tested",
      "   - Data flow verification",
      "   - Error handling coverage",
      "5. Performance Impact",
      "   - Benchmark comparisons",
      "   - Resource utilization",
      "   - Scalability analysis",
      "6. Documentation Updates",
      "   - API documentation",
      "   - Integration guides",
      "   - Example usage"
    ]
  },
  "validation": {
    "checklist": [
      "All specified tests pass",
      "No regression in existing tests",
      "Integration points properly tested",
      "Performance targets met",
      "Security requirements satisfied",
      "Documentation complete"
    ],
    "quality_gates": {
      "coverage": "Minimum 90% for new code",
      "performance": "No degradation > 5%",
      "security": "Pass security audit",
      "integration": "All integration tests pass"
    }
  },
  "error_handling": {
    "test_not_found": "Test file not found - verify path and suggest alternatives",
    "implementation_error": "Compilation or runtime errors with fix suggestions",
    "test_failure": "Detailed test failure analysis with debugging steps",
    "integration_failure": "Component integration issues with resolution path",
    "performance_regression": "Performance degradation detected with optimization hints"
  }
}